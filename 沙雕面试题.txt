
1、对象之间的关系：
	#泛化：泛化是一种一般与特殊、一般与具体之间关系的描述，具体描述建立在一般描述的基础之上，并对其进行了扩展。
	son————————————|>father
	符号：————————————|>（实线+三角形箭头）
	
	#实现：实现是一种类与接口的关系，表示类是接口所有特征和行为的实现，在程序中一般通过类实现接口来描述
	man------------|>run
	符号：------------|>（虚线+三角形箭头）

	#依赖：依赖关系仅仅描述了类与类之间的一种使用与被使用的关系;举例：汽车的行进依赖于汽油的燃烧。
	static class Boat{ 
		public static void row(){ 
			System.out.println("开动"); 
		} 
	} 
	class Person{ 
		public void crossRiver(Boat boat){ 
			boat.row() ; 
		} 
	}
	符号：------------>
	#关联：关联关系使一个类知道另外一个类的属性和方法;
	class Person{
		private Heart heart;
		public Person(Heart heart)
		{
			this.heart=heart;
		}
	}
	符号：————————————>
	#聚合：是关联关系的一种。是整体和个体/部分之间的关系;在聚合关系中,代表个体/部分的对象有可能会被多个代表整体的对象所共享;
	class Classes{ 
		private Student student ; 
		public Classes(Student student){ 
			this.student = student ; 
		} 
	} 
	符号：<————————————◇(空心菱形 + 实线 + 箭头;箭头指向被聚合的类,也就是说,箭头指向个体/部分;)
	#组合:也是关联关系的一种。但它是比聚合关系更强的关系.组合关系要求聚合关系中代表整体的对象要负责代表个体/部分的对象的整个生命周期。如果代表整体的对象被销毁或破坏,那么代表个体/部分的对象也一定会被销毁或破坏。
	class House{
		private Room room ;
		public House(){
			room = new Room() ;
		}
	}
	符号：<————————————◆图示:实心菱形 + 实线 + 箭头;箭头指向代表个体/部分的对象,也就是被合成/组合的类的对象;
		
2、Spring原理
	#IOC（控制反转）：https://blog.csdn.net/qq_22654611/article/details/52606960/
		它是一种设计思想。Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。
		传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建。
		为什么叫反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；依赖对象的获取途径被反转了。
		由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。
		DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定。即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。
		●谁依赖于谁：当然是应用程序依赖于IoC容器；

　		●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；

　　	●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；

　　	●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。

		注入方法:
		1、构造函数注入：
			在构造函数注入中，我们通过调用类的构造函数，将需要用到的依赖对象传入。
			但是，如果我们并不始终需要用到这些对象，就没必要在创建的时候就将他们传入了。于是，这时候我们就需要用到（属性注入）SetGet注入。
		2、属性注入：
			即通过set和get方法，将依赖对象传入到所需构造的对象中。
		3、接口注入：
			将调用类所有依赖注入的方法抽取到一个接口中，调用类通过实现该接口提供相应的注入方法。
			为了采取接口注入的方式，必须先声明一个接口： 
			public interface IntMethod {  
				void intway(Aclass something);  
			} 
		   然后，具体的类实现接口中的方法
			public class Need implements IntMethod {  
				private Aclass a;  
				 //①实现接口方法  
				public void intway (Aclass something) {    
					this.a = something;         
				}  
			}
			ioc通过调用接口的方式，来实现注入。
			由于通过接口注入需要额外声明一个接口，增加了类的数目，而且它的效果和属性注入并无本质区别，因此我们不提倡采用这种方式。 
			
		Spring通过配置文件或注解描述类和类之间的依赖关系，自动完成类的初始化和依赖注入的工作。
		通过new XmlBeanFactory(“beans.xml”)等方式即可启动容器。在容器启动时，Spring根据配置文件的描述信息，自动实例化Bean并完成依赖关系的装配，从容器中即可返回准备就绪的Bean实例，
		后续可直接使用之。
		
	#AOP（面向切面编程）：
	这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。 
	它用到了动态代理
	https://blog.csdn.net/sinat_21843047/article/details/80299366

3、Bean的作用域有哪些？

singleton：在spring ioc容器中仅存在一个Bean实例，Bean以单实例的方式存在

prototype：每次从容器中调用bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行new xxxBean()的操作

request：每次HTTP请求都会创建一个新的Bean。该作用域仅适用于WebApplicationContext环境

Session：同一个HTTP session共享一个Bean，不同的HTTP session使用不同的Bean。该作用域仅适用于WebApplicationContext环境

globalSession：同一个全局session共享一个Bean，一般用于Portlet应用环境。该作用域仅适用于WebApplicationContext环境

4、HashMap和HashTable的区别：
	#1、继承的类不同： 
	Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。
	#2、线程安全性不同： 
	HashMap线程不安全，Hashtable线程安全。
	#3、是否包含contains方法：
	HashMap不包含contains方法，只有containsKey和containsValue方法。
	因为contains容易产生误会，实际上它的效果和只有containsKey是一样的。HashTable三个方法都有。
	#4、key和value是否允许null值：
	HashTable不允许key和value出现空值，而HashMap允许。
	#5、hash值的计算方法不同：
	HashTable：(key.hashCode()& 0x7FFFFFFF) % tab.length;
	HashMap：(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)
	#6、内部实现使用的数组初始化和扩容方式不同 
	HashTable在不指定容量的情况下的默认容量为11，而HashMap为16。
	Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。
	Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。

5、linux常用命令：
	ls命令：可以查看linux文件夹包含的文件，还可以查看文件权限(包括目录、文件夹、文件权限)、查看目录信息等等。
	cd命令：切换当前目录至dirName。
	pwd命令：查看当前工作目录路径。
	mkdir命令：创建文件夹
	rm命令：删除一个目录中的一个或多个文件或目录
	rmdir命令： 从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。
	mv命令：移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。     
	cp命令：   将源文件复制至目标文件，或将多个源文件复制至目标目录。
	cat命令：
		1.一次显示整个文件:cat filename
        2.从键盘创建一个文件:cat > filename 只能创建新文件,不能编辑已有文件.
        3.将几个文件合并为一个文件:cat file1 file2 > file
	head命令：显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。
	find命令：用于在文件树中查找文件，并作出相应的处理。
	tar命令：用来压缩和解压文件。tar本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。
		tar  -zcvf  /root/1.tar   /root/a     将root目录下的a文件夹压缩成1.tar,放在root目录下。
		tar  -zxvf  ./1.tar        将当前目录下的1.tar文件解压缩
	wc命令：统计指定的文件中字节数、字数、行数，并将统计结果输出。
	ps命令：查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用top。
	top命令：显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等
	kill命令： 发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果任无法终止该程序可用“-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程。
	#参考资料：https://www.cnblogs.com/gaojun/p/3359355.html
6、mybatis相关：
	'#'和'$'的区别：
	'#'是预编译处理，是字符串替换。Mybatis 在处理'#'时，会将sql 中的'#'替换为?号，调用PreparedStatement 的
	set 方法来赋值;在处理'$'时，只是把'$'替换成变量的值。 使用#可以有效的防止 SQL 注入，提高系统安全性。
	=、>、<、!=的写法：
		第一种写法：
		等于	:    =
		小于    :    &lt;
		小于等于:    &lt;=
		大于	:    &gt;
		大于等于:    &gt;= 
		与		:    &amp;
		第二种写法：
		大于等于:  a <![CDATA[>= ]]>b
		小于等于:  a <![CDATA[<= ]]>b
		不等于  :  a <![CDATA[ <> ]]>b或a <![CDATA[!= ]]>b
7、如何使用sql语句复制表？
	create table t1 like t2#不复制表数据
	create table t1 as select * from t2#复制表头以及表数据
	insert into t1 select * from t2#将表2的数据插入到表1中

8、
集群和分布式的区别：
https://www.zhihu.com/question/20004877（大闲人柴毛毛）
集群：
单机处理到达瓶颈的时候，你就把单机复制几份，这样就构成了一个“集群”。集群中每台服务器就叫做这个集群的一个“节点”，所有节点构成了一个集群。每个节点都提供相同的服务，那么这样系统的处理能力就相当于提升了好几倍（有几个节点就相当于提升了这么多倍）。但问题是用户的请求究竟由哪个节点来处理呢？最好能够让此时此刻负载较小的节点来处理，这样使得每个节点的压力都比较平均。要实现这个功能，就需要在所有节点之前增加一个“调度者”的角色，用户的所有请求都先交给它，然后它根据当前所有节点的负载情况，决定将这个请求交给哪个节点处理。这个“调度者”有个牛逼了名字——负载均衡服务器。集群结构的好处就是系统扩展非常容易。如果随着你们系统业务的发展，当前的系统又支撑不住了，那么给这个集群再增加节点就行了。但是，当你的业务发展到一定程度的时候，你会发现一个问题——无论怎么增加节点，貌似整个集群性能的提升效果并不明显了。这时候，你就需要使用微服务结构了。
分布式：
分布式结构就是将一个完整的系统，按照业务功能，拆分成一个个独立的子系统，在分布式结构中，每个子系统就被称为“服务”。这些子系统能够独立运行在web容器中，它们之间通过RPC方式通信。

微服务：
https://www.zhihu.com/question/65502802

rpc：
https://www.zhihu.com/question/25536695
RPC就是远程过程调用——要像调用本地的函数一样去调远程函数。
在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，Multiply是在另一个进程中执行的。这就带来了几个新问题：Call ID映射。我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 <--> Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。序列化和反序列化。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。网络传输。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。
9.并发与并行的区别：
并发： 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；
并行： 单位时间内，多个任务同时执行。
10、Http和Https的区别
　HTTPS和HTTP的区别主要如下：

　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
11、TCP定时器
	TCP使用四种定时器（Timer，也称为“计时器”）：
	重传计时器：Retransmission Timer
	坚持计时器：Persistent Timer
	保活计时器：Keeplive Timer
	时间等待计时器：Time_Wait Timer。
	<1>重传计时器：
	为了控制丢失的报文段或丢弃的报文段，也就是对报文段确认的等待时间。当TCP发送报文段时，就创建这个特定报文段的重传计时器，可能发生两种情况：若在计时器超时之前收到对报文段的确认，则撤销计时器；若在收到对特定报文段的确认之前计时器超时，则重传该报文，并把计时器复位；

	重传时间=2*RTT；

	RTT的值应该动态计算。常用的公式是：RTT=previous RTT*i + （1-i）*current RTT。i的值通常取90%，即新的RTT是以前的RTT值的90%加上当前RTT值的10%.

	Karn算法：对重传报文，在计算新的RTT时，不考虑重传报文的RTT。因为无法推理出：发送端所收到的确认是对上一次报文段的确认还是对重传报文段的确认。干脆不计入。

	<2>坚持计时器：persistent timer

	专门为对付零窗口通知而设立的。

	当发送端收到零窗口的确认时，就启动坚持计时器，当坚持计时器截止期到时，发送端TCP就发送一个特殊的报文段，叫探测报文段，这个报文段只有一个字节的数据。探测报文段有序号，但序号永远不需要确认，甚至在计算对其他部分数据的确认时这个序号也被忽略。探测报文段提醒接收端TCP，确认已丢失，必须重传。

	坚持计时器的截止期设置为重传时间的值，但若没有收到从接收端来的响应，则发送另一个探测报文段，并将坚持计时器的值加倍和并复位，发送端继续发送探测报文段，将坚持计时器的值加倍和复位，知道这个值增大到阈值为止（通常为60秒）。之后，发送端每隔60s就发送一个报文段，直到窗口重新打开为止；

	<3>保活计时器：keeplive timer

	每当服务器收到客户的信息，就将keeplive timer复位，超时通常设置2小时，若服务器超过2小时还没有收到来自客户的信息，就发送探测报文段，若发送了10个探测报文段（没75秒发送一个）还没收到响应，则终止连接。

	<4>时间等待计时器：Time_Wait Timer

	在连接终止期使用，当TCP关闭连接时，并不认为这个连接就真正关闭了，在时间等待期间，连接还处于一种中间过度状态。这样就可以时重复的fin报文段在到达终点后被丢弃，这个计时器的值通常设置为一格报文段寿命期望值的两倍。

12、快速重传、快速恢复

13、如何使用select语句将查询结果横向显示？
		比如表T为
			Year    Season     Num
			2010	  1			5
			2010      2         7
			2010	  3			5
			2010      4         7
			2011      1         7
			2011      2         10
			2011      3         5
			2011      4         4
			
		查询结果为：
			year    第一季度     第二季度     第三季度     第四极度 
			2010        5            7            5            7
			2011        7            10           5            4
		
		语句：
			#方法1：
				select Year,
				SUM(case Season when 1 then Num else 0 end) as 第一季度,
				SUM(case Season when 2 then Num else 0 end) as 第二季度,
				SUM(case Season when 3 then Num else 0 end) as 第三季度,
				SUM(case Season when 4 then Num else 0 end) as 第四季度
				from T
					group by year;
			#方法2：
				select Year,
				SUM(if (Season=1,Num,0)) as 第一季度,
				SUM(if (Season=2,Num,0)) as 第二季度,
				SUM(if (Season=3,Num,0)) as 第三季度,
				SUM(if (Season=4,Num,0)) as 第四季度
				from T
					group by year;
					
		反过来：
			#复制表
				create Table T2 select Year,
				SUM(if (Season=1,Num,0)) as 第一季度,
				SUM(if (Season=2,Num,0)) as 第二季度,
				SUM(if (Season=3,Num,0)) as 第三季度,
				SUM(if (Season=4,Num,0)) as 第四季度
				from T
					group by year;
					
			#列传行		
				select year,season,num from(
					select year ,1 as Season,第一季度 as Num from t2
						union ALL
						select year ,2 as Season,第二季度 as Num from t2
						union ALL
						select year ,3 as Season,第三季度 as Num from t2
						union ALL
						select year ,4 as Season,第四季度 as Num from t2)
					as t3 order by year;
14、java线程和操作系统线程的关系
	内核线程（KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口—轻量级进程（LWP），轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都是由一个内核线程支持(关系为1:1)；

	对于Sun JDK来说，它的Window版与Linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程中。

15、静态链接库和动态链接库的区别？
	Linux下得库有动态与静态两种，动态通常用.so为后缀，静态用.a为后缀。面对比一下两者：

	静态链接库：当要使用时，连接器会找出程序所需的函数，然后将它们拷贝到执行文件，由于这种拷贝是完整的，所以一旦连接成功，静态程序库也就不再需要了。

	动态库而言：某个程序在运行中要调用某个动态链接库函数的时候，操作系统首先会查看所有正在运行的程序，看在内存里是否已有此库函数的拷贝了。如果有，则让其共享那一个拷贝；只有没有才链接载入。在程序运行的时候，被调用的动态链接库函数被安置在内存的某个地方，所有调用它的程序将指向这个代码段。因此，这些代码必须使用相对地址，而不是绝对地址。在编译的时候，我们需要告诉编译器，这些对象文件是用来做动态链接库的，所以要用地址无关代码（Position Independent Code (PIC))。

	动态链接库的加载方式有两种：隐式加载和显示加载。

	注意：linux下进行连接的缺省操作是首先连接动态库，也就是说，如果同时存在静态和动态库，不特别指定的话，将与动态库相连接
